// =============================================================================
// server.js - 應用程式主入口文件 (已更新為 Docker Compose 環境)
// 負責啟動 Express 伺服器、連接 MongoDB、設定中介軟體和路由
// =============================================================================

const express = require('express');
const mongoose = require('mongoose');
const path = require('path');
const urlController = require('./controllers/urlController'); // 引入 URL 控制器

const app = express();
const PORT = process.env.PORT || 3000;
// *** Docker Compose 環境下，MongoDB 服務名稱為 'mongodb' ***
// 請確保你的 MongoDB 服務正在運行，並且連接 URI 正確
// 如果 MongoDB 在不同的主機或端口，請修改這裡
const DB_URI = 'mongodb://mongodb:27017/shorturl_db'; // <--- 這裡從 localhost 改為 mongodb

// 連接 MongoDB 資料庫
// 增加 serverSelectionTimeoutMS，給予 MongoDB 更多時間啟動和響應
mongoose.connect(DB_URI, { serverSelectionTimeoutMS: 30000 }) // <--- 增加超時設定
    .then(() => console.log('MongoDB connected successfully'))
    .catch(err => console.error('MongoDB connection error:', err));

// 設定 Express 中介軟體
app.use(express.json()); // 解析 JSON 格式的請求體
app.use(express.urlencoded({ extended: true })); // 解析 URL-encoded 格式的請求體
app.use(express.static(path.join(__dirname, 'public'))); // 提供靜態檔案 (例如: index.html, script.js, CSS)

// =============================================================================
// 路由定義
// =============================================================================

// GET /:shortId
// 用於處理短網址的導向請求，會將使用者重新導向到原始的長網址
app.get('/:shortId', urlController.redirectToLongUrl);

// POST /api/shorten
// 用於接收前端的縮網址請求，生成短網址並儲存到資料庫
app.post('/api/shorten', urlController.shortenUrl);

// GET /api/urls/:shortId
// 用於獲取指定短網址的詳細資訊，包含點擊數據等，供流量分析使用
app.get('/api/urls/:shortId', urlController.getShortUrlDetails);

// PUT /api/urls/:shortId
// 用於更新指定短網址的目標長網址
app.put('/api/urls/:shortId', urlController.updateTargetUrl);

// GET /
// 應用程式的根路由，導向到前端的 index.html 頁面
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// 啟動伺服器
app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});

// =============================================================================
// models/Url.js - MongoDB 資料模型定義
// 定義了短網址及其相關點擊數據的資料結構
// =============================================================================

// 這個部分應該放在 models/Url.js 檔案中
const mongoose = require('mongoose'); // 這裡需要解除註解
const shortid = require('shortid'); // 這裡需要解除註解

// 定義單次點擊的資料結構
const clickSchema = new mongoose.Schema({
    timestamp: { type: Date, default: Date.now }, // 點擊時間
    ipAddress: String, // 點擊者的 IP 位址
    country: String, // 國家
    region: String, // 區域/省份
    city: String, // 城市
    os: String, // 作業系統 (e.g., Windows 10, iOS 15)
    deviceType: String, // 裝置類型 (e.g., desktop, mobile, tablet)
    browser: String, // 瀏覽器 (e.g., Chrome 100, Safari 15)
    referrer: String, // 流量來源網址
});

// 定義短網址的資料結構
const urlSchema = new mongoose.Schema({
    longUrl: {
        type: String,
        required: true // 長網址是必填的
    },
    shortId: {
        type: String,
        required: true,
        unique: true, // 短 ID 必須是唯一的
        default: shortid.generate // 預設使用 shortid 庫自動生成
    },
    customShortId: { // 允許使用者自訂短網址路徑
        type: String,
        unique: true,
        sparse: true // 允許此欄位為空，但如果存在則必須唯一
    },
    createdAt: {
        type: Date,
        default: Date.now // 創建時間預設為當前時間
    },
    expiresAt: Date, // 短網址的到期時間 (可選)
    password: String, // 密碼保護 (可選)
    totalClicks: {
        type: Number,
        default: 0 // 總點擊數，預設為 0
    },
    clicks: [clickSchema] // 儲存所有點擊的詳細資訊，是一個 ClickSchema 陣列
});

const Url = mongoose.model('Url', urlSchema); // 建立 Url 模型
module.exports = Url; // 實際檔案中會這樣導出

// =============================================================================
// controllers/urlController.js - 處理 URL 相關邏輯
// 包含縮網址、導向、獲取分析數據和更新目標網址的功能
// =============================================================================

// 這個部分應該放在 controllers/urlController.js 檔案中
const Url = require('../models/Url'); // 實際檔案中會這樣引入
const validator = require('validator');
const shortid = require('shortid'); // 這裡需要解除註解
const useragent = require('useragent-parser');
const geoip = require('geoip-lite');

// 輔助函數：根據 IP 位址獲取地理位置資訊
const getGeoInfo = (ip) => {
    if (!ip) return {};
    // 處理 IPv6 位址，geoip-lite 可能需要 IPv4 或特定格式
    const ipv4 = ip.includes('::ffff:') ? ip.split('::ffff:')[1] : ip;
    const geo = geoip.lookup(ipv4);
    return {
        country: geo ? geo.country : 'Unknown',
        region: geo ? geo.region : 'Unknown',
        city: geo ? geo.city : 'Unknown',
    };
};

// 輔助函數：根據 User-Agent 字串獲取作業系統、裝置和瀏覽器資訊
const getUserAgentInfo = (userAgentHeader) => {
    if (!userAgentHeader) return {};
    const agent = useragent.parse(userAgentHeader);
    return {
        os: agent.os.name ? `${agent.os.name} ${agent.os.version || ''}`.trim() : 'Unknown',
        deviceType: agent.device.type || 'Unknown', // 例如: mobile, tablet, desktop
        browser: agent.browser.name ? `${agent.browser.name} ${agent.browser.version || ''}`.trim() : 'Unknown',
    };
};

// 縮網址功能
exports.shortenUrl = async (req, res) => {
    const { longUrl, customShortId, expiresAt, password } = req.body;

    // 驗證輸入的長網址是否為有效 URL
    if (!longUrl || !validator.isURL(longUrl, { require_protocol: true })) {
        return res.status(400).json({ error: 'Invalid URL provided. Please include http:// or https://' });
    }

    try {
        let shortIdToUse;
        if (customShortId) {
            // 如果提供了自訂短網址，檢查是否已被使用
            const existingCustomUrl = await Url.findOne({ customShortId });
            if (existingCustomUrl) {
                return res.status(409).json({ error: 'Custom short ID is already in use.' });
            }
            shortIdToUse = customShortId;
        } else {
            // 如果沒有提供自訂短網址，則自動生成一個
            shortIdToUse = shortid.generate();
        }

        // 創建新的 Url 文件
        const newUrl = new Url({
            longUrl,
            shortId: shortIdToUse,
            customShortId: customShortId || undefined, // 如果沒有自訂，則不儲存此欄位
            expiresAt: expiresAt ? new Date(expiresAt) : undefined, // 轉換為 Date 物件
            password: password || undefined,
        });

        await newUrl.save(); // 儲存到資料庫

        // 返回生成的短網址給前端
        res.status(201).json({
            shortUrl: `${req.protocol}://${req.get('host')}/${newUrl.shortId}`
        });

    } catch (err) {
        console.error('Error shortening URL:', err);
        // 處理可能的唯一索引衝突 (例如 shortId 重複，雖然 shortid.generate 衝突機率極低)
        if (err.code === 11000) {
            return res.status(409).json({ error: 'A short ID conflict occurred. Please try again or choose a different custom ID.' });
        }
        res.status(500).json({ error: 'Server error during URL shortening.' });
    }
};

// 導向長網址並記錄點擊數據
exports.redirectToLongUrl = async (req, res) => {
    const { shortId } = req.params;
    // 獲取客戶端 IP 位址 (考慮代理伺服器)
    const ipAddress = req.headers['x-forwarded-for'] ? req.headers['x-forwarded-for'].split(',')[0].trim() : req.connection.remoteAddress;
    const userAgentHeader = req.headers['user-agent']; // 獲取 User-Agent 字串
    const referrer = req.headers['referer'] || 'Direct'; // 獲取來源網址

    try {
        const urlEntry = await Url.findOne({ shortId });

        if (!urlEntry) {
            return res.status(404).send('Short URL not found.');
        }

        // 檢查短網址是否過期
        if (urlEntry.expiresAt && urlEntry.expiresAt < new Date()) {
            return res.status(410).send('Short URL has expired.');
        }

        // 檢查是否有密碼保護 (此處僅為簡單提示，實際應用需導向密碼驗證頁面)
        if (urlEntry.password) {
            // 實際應用中，這裡會導向一個密碼輸入頁面，然後再驗證
            return res.status(401).send('This URL is password protected. Please provide the password to access.');
        }

        // 記錄點擊資訊
        const geoInfo = getGeoInfo(ipAddress);
        const uaInfo = getUserAgentInfo(userAgentHeader);

        urlEntry.clicks.push({
            ipAddress,
            ...geoInfo,
            ...uaInfo,
            referrer,
        });
        urlEntry.totalClicks++; // 總點擊數加一
        await urlEntry.save(); // 更新資料庫

        res.redirect(urlEntry.longUrl); // 重新導向到原始長網址

    } catch (err) {
        console.error('Error redirecting URL:', err);
        res.status(500).send('Server error during redirection.');
    }
};

// 獲取短網址的詳細資訊 (流量分析用)
exports.getShortUrlDetails = async (req, res) => {
    const { shortId } = req.params;

    try {
        const urlEntry = await Url.findOne({ shortId });

        if (!urlEntry) {
            return res.status(404).json({ error: 'Short URL not found.' });
        }

        // 為了避免返回過大的數據，這裡只返回最近的點擊紀錄
        // 實際應用中，流量分析會更複雜，可能需要聚合管道 (aggregation pipeline)
        // 來計算國家分佈、裝置分佈、時間趨勢等
        const analysis = {
            longUrl: urlEntry.longUrl,
            totalClicks: urlEntry.totalClicks,
            createdAt: urlEntry.createdAt,
            expiresAt: urlEntry.expiresAt,
            passwordProtected: !!urlEntry.password, // 是否有密碼保護
            recentClicks: urlEntry.clicks.slice(-20).reverse(), // 只顯示最近 20 筆點擊，並倒序排列 (最新在前)
            // 你可以在這裡添加更多聚合數據，例如：
            // countryDistribution: await Url.aggregate([
            //     { $match: { shortId: shortId } },
            //     { $unwind: '$clicks' },
            //     { $group: { _id: '$clicks.country', count: { $sum: 1 } } },
            //     { $sort: { count: -1 } }
            // ]),
            // osDistribution: await Url.aggregate([
            //     { $match: { shortId: shortId } },
            //     { $unwind: '$clicks' },
            //     { $group: { _id: '$clicks.os', count: { $sum: 1 } } },
            //     { $sort: { count: -1 } }
            // ]),
        };

        res.json(analysis);

    } catch (err) {
        console.error('Error fetching URL details:', err);
        res.status(500).json({ error: 'Server error during fetching URL details.' });
    }
};

// 更新目標網址
exports.updateTargetUrl = async (req, res) => {
    const { shortId } = req.params;
    const { newLongUrl } = req.body;

    // 驗證新的目標網址是否為有效 URL
    if (!newLongUrl || !validator.isURL(newLongUrl, { require_protocol: true })) {
        return res.status(400).json({ error: 'Invalid new URL provided. Please include http:// or https://' });
    }

    try {
        // 找到對應的短網址條目
        const urlEntry = await Url.findOne({ shortId });

        if (!urlEntry) {
            return res.status(404).json({ error: 'Short URL not found.' });
        }

        urlEntry.longUrl = newLongUrl; // 更新長網址
        await urlEntry.save(); // 儲存更新

        res.json({ message: 'Target URL updated successfully.', newLongUrl: urlEntry.longUrl });

    } catch (err) {
        console.error('Error updating target URL:', err);
        res.status(500).json({ error: 'Server error during updating target URL.' });
    }
};

// =============================================================================
// public/index.html - 前端 HTML 頁面
// 提供了縮網址、更改目標網址和流量分析的簡單介面
// =============================================================================

/*
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的縮網址系統</title>
    <style>
        body { font-family: 'Inter', Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f2f5; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; }
        .container {
            background: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 700px;
            box-sizing: border-box;
        }
        h1 { color: #333; text-align: center; margin-bottom: 30px; }
        .tabs { display: flex; margin-bottom: 20px; border-bottom: 2px solid #e0e0e0; }
        .tab-button {
            flex: 1;
            padding: 12px 0;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 16px;
            color: #555;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            border-radius: 8px 8px 0 0;
        }
        .tab-button:hover { background-color: #f7f7f7; }
        .tab-button.active {
            color: #007bff;
            border-bottom: 3px solid #007bff;
            font-weight: bold;
            background-color: #fff;
        }
        .tab-content { padding: 20px 0; display: none; animation: fadeIn 0.5s ease-out; }
        .tab-content.active { display: block; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .section-header {
            font-size: 1.3em;
            color: #444;
            margin-top: 20px;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        input[type="text"], input[type="url"], input[type="password"], input[type="datetime-local"] {
            width: calc(100% - 24px);
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 16px;
            box-sizing: border-box;
            transition: border-color 0.3s ease;
        }
        input[type="text"]:focus, input[type="url"]:focus, input[type="password"]:focus, input[type="datetime-local"]:focus {
            border-color: #007bff;
            outline: none;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.2);
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 17px;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.2);
        }
        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }
        .result {
            margin-top: 25px;
            padding: 15px;
            background-color: #e9f7ff;
            border: 1px solid #cceeff;
            border-radius: 8px;
            font-size: 15px;
            color: #333;
            word-wrap: break-word;
        }
        .result a { color: #007bff; text-decoration: none; font-weight: bold; }
        .result a:hover { text-decoration: underline; }
        .error-message {
            color: #dc3545;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 14px;
        }
        ul { list-style: none; padding: 0; }
        ul li { background-color: #f8f9fa; margin-bottom: 8px; padding: 10px; border-radius: 5px; border: 1px solid #e9ecef; }
        @media (max-width: 768px) {
            .container { margin: 10px; padding: 20px; }
            .tab-button { font-size: 14px; padding: 10px 0; }
            input, button { font-size: 14px; padding: 10px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>我的縮網址系統</h1>

        <div class="tabs">
            <button class="tab-button active" onclick="openTab(event, 'shorten')">縮網址</button>
            <button class="tab-button" onclick="openTab(event, 'update')">更改目標網址</button>
            <button class="tab-button" onclick="openTab(event, 'analyze')">流量分析</button>
        </div>

        <div id="shorten" class="tab-content active">
            <h2 class="section-header">縮網址</h2>
            <input type="url" id="longUrlInput" placeholder="輸入要縮短的長網址 (e.g., https://example.com/very/long/url)" required>
            <input type="text" id="customShortIdInput" placeholder="自訂短網址路徑 (可選, e.g., my-link)">
            <input type="datetime-local" id="expiresAtInput" placeholder="到期時間 (可選)">
            <input type="password" id="passwordInput" placeholder="密碼保護 (可選)">
            <button onclick="shortenUrl()">縮短網址</button>
            <div id="shortenResult" class="result"></div>
        </div>

        <div id="update" class="tab-content">
            <h2 class="section-header">更改目標網址</h2>
            <input type="text" id="updateShortId" placeholder="輸入要更新的短網址 ID (e.g., abcdef)">
            <input type="url" id="newLongUrl" placeholder="輸入新的目標網址 (e.g., https://new-example.com)" required>
            <button onclick="updateUrl()">更新網址</button>
            <div id="updateResult" class="result"></div>
        </div>

        <div id="analyze" class="tab-content">
            <h2 class="section-header">流量分析</h2>
            <input type="text" id="analyzeShortId" placeholder="輸入要分析的短網址 ID (e.g., abcdef)">
            <button onclick="analyzeUrl()">分析流量</button>
            <div id="analyzeResult" class="result"></div>
        </div>
    </div>

    <script src="script.js"></script>
</body>
</html>
*/

// =============================================================================
// public/script.js - 前端 JavaScript 邏輯
// 處理前端的互動、發送 API 請求並顯示結果
// =============================================================================

/*
document.addEventListener('DOMContentLoaded', () => {
    // 預設將到期時間設為一個月後
    const expiresAtInput = document.getElementById('expiresAtInput');
    if (expiresAtInput) {
        const now = new Date();
        now.setMonth(now.getMonth() + 1); // 設定為一個月後
        // 格式化為儼-MM-DDTHH:MM，符合 datetime-local 輸入框的要求
        expiresAtInput.value = now.toISOString().slice(0, 16);
    }

    // 初始化時顯示第一個 Tab
    openTab(null, 'shorten');
});

// 切換 Tab 頁面
function openTab(evt, tabName) {
    var i, tabContent, tabButtons;
    tabContent = document.getElementsByClassName("tab-content");
    for (i = 0; i < tabContent.length; i++) {
        tabContent[i].style.display = "none"; // 隱藏所有 Tab 內容
        tabContent[i].classList.remove('active');
    }
    tabButtons = document.getElementsByClassName("tab-button");
    for (i = 0; i < tabButtons.length; i++) {
        tabButtons[i].classList.remove("active"); // 移除所有 Tab 按鈕的 active 樣式
    }
    document.getElementById(tabName).style.display = "block"; // 顯示當前選中的 Tab 內容
    document.getElementById(tabName).classList.add('active');
    if (evt) { // 避免初始化時傳入 null
        evt.currentTarget.classList.add("active"); // 為當前選中的 Tab 按鈕添加 active 樣式
    } else { // 首次載入時，手動設定第一個按鈕 active
        document.querySelector('.tab-button').classList.add('active');
    }
}

// 縮網址功能
async function shortenUrl() {
    const longUrl = document.getElementById('longUrlInput').value;
    const customShortId = document.getElementById('customShortIdInput').value;
    const expiresAt = document.getElementById('expiresAtInput').value;
    const password = document.getElementById('passwordInput').value;
    const resultDiv = document.getElementById('shortenResult');
    resultDiv.innerHTML = ''; // 清空之前結果

    if (!longUrl) {
        resultDiv.innerHTML = '<p class="error-message">請輸入長網址。</p>';
        return;
    }

    try {
        const response = await fetch('/api/shorten', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                longUrl,
                customShortId: customShortId || undefined,
                expiresAt: expiresAt || undefined,
                password: password || undefined
            })
        });

        const data = await response.json();

        if (response.ok) {
            resultDiv.innerHTML = `
                <p>短網址已生成:</p>
                <p><a href="${data.shortUrl}" target="_blank">${data.shortUrl}</a></p>
                <p>請複製此網址並分享！</p>
            `;
            // 清空輸入框
            document.getElementById('longUrlInput').value = '';
            document.getElementById('customShortIdInput').value = '';
            document.getElementById('passwordInput').value = '';
            // 重設到期時間
            const expiresAtInput = document.getElementById('expiresAtInput');
            const now = new Date();
            now.setMonth(now.getMonth() + 1);
            expiresAtInput.value = now.toISOString().slice(0, 16);
        } else {
            resultDiv.innerHTML = `<p class="error-message">錯誤: ${data.error || '未知錯誤'}</p>`;
        }
    } catch (error) {
        console.error('縮網址請求失敗:', error);
        resultDiv.innerHTML = '<p class="error-message">網路或伺服器錯誤，請檢查控制台。</p>';
    }
}

// 更新目標網址功能
async function updateUrl() {
    const shortId = document.getElementById('updateShortId').value;
    const newLongUrl = document.getElementById('newLongUrl').value;
    const resultDiv = document.getElementById('updateResult');
    resultDiv.innerHTML = '';

    if (!shortId || !newLongUrl) {
        resultDiv.innerHTML = '<p class="error-message">請輸入短網址 ID 和新的目標網址。</p>';
        return;
    }

    try {
        const response = await fetch(`/api/urls/${shortId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ newLongUrl })
        });

        const data = await response.json();

        if (response.ok) {
            resultDiv.innerHTML = `<p>目標網址已更新成功！新的目標網址: <a href="${data.newLongUrl}" target="_blank">${data.newLongUrl}</a></p>`;
            document.getElementById('updateShortId').value = '';
            document.getElementById('newLongUrl').value = '';
        } else {
            resultDiv.innerHTML = `<p class="error-message">錯誤: ${data.error || '未知錯誤'}</p>`;
        }
    } catch (error) {
        console.error('更新網址請求失敗:', error);
        resultDiv.innerHTML = '<p class="error-message">網路或伺服器錯誤，請檢查控制台。</p>';
    }
}

// 流量分析功能
async function analyzeUrl() {
    const shortId = document.getElementById('analyzeShortId').value;
    const resultDiv = document.getElementById('analyzeResult');
    resultDiv.innerHTML = '';

    if (!shortId) {
        resultDiv.innerHTML = '<p class="error-message">請輸入要分析的短網址 ID。</p>';
        return;
    }

    try {
        const response = await fetch(`/api/urls/${shortId}`);
        const data = await response.json();

        if (response.ok) {
            let clicksHtml = '<h3>最近點擊紀錄 (最多 20 筆):</h3>';
            if (data.recentClicks && data.recentClicks.length > 0) {
                clicksHtml += '<ul>';
                data.recentClicks.forEach(click => {
                    clicksHtml += `<li>
                        <strong>時間:</strong> ${new Date(click.timestamp).toLocaleString()}<br>
                        <strong>IP:</strong> ${click.ipAddress}<br>
                        <strong>國家/城市:</strong> ${click.country} ${click.city ? `(${click.city})` : ''}<br>
                        <strong>裝置:</strong> ${click.deviceType} (${click.os})<br>
                        <strong>瀏覽器:</strong> ${click.browser}<br>
                        <strong>來源:</strong> ${click.referrer || '直接訪問'}
                    </li>`;
                });
                clicksHtml += '</ul>';
            } else {
                clicksHtml += '<p>目前沒有點擊紀錄。</p>';
            }

            resultDiv.innerHTML = `
                <p><strong>原始網址:</strong> <a href="${data.longUrl}" target="_blank">${data.longUrl}</a></p>
                <p><strong>總點擊數:</strong> ${data.totalClicks}</p>
                <p><strong>創建時間:</strong> ${new Date(data.createdAt).toLocaleString()}</p>
                ${data.expiresAt ? `<p><strong>到期時間:</strong> ${new Date(data.expiresAt).toLocaleString()}</p>` : '<p><strong>到期時間:</strong> 無設定</p>'}
                ${data.passwordProtected ? '<p><strong>密碼保護:</strong> 是</p>' : '<p><strong>密碼保護:</strong> 否</p>'}
                ${clicksHtml}
                <!-- 這裡可以添加更多圖表和數據聚合，例如：
                <canvas id="countryChart"></canvas>
                <canvas id="deviceChart"></canvas>
                <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
                <script>
                    // 在這裡根據 data.countryDistribution 和 data.deviceDistribution 繪製圖表
                    // 這需要後端提供更多聚合數據
                </script>
                -->
            `;
        } else {
            resultDiv.innerHTML = `<p class="error-message">錯誤: ${data.error || '未知錯誤'}</p>`;
        }
    } catch (error) {
        console.error('流量分析請求失敗:', error);
        resultDiv.innerHTML = '<p class="error-message">網路或伺服器錯誤，請檢查控制台。</p>';
    }
}
*/

// =============================================================================
// Dockerfile - 用於建構 Node.js 應用程式的 Docker 映像
// (此檔案在直接使用 Node.js Image 的情況下可以刪除或作為備用)
// =============================================================================

/*
# 使用官方 Node.js 18 LTS 映像作為基礎映像
FROM node:18-alpine

# 設定工作目錄
WORKDIR /app

# 將 package.json 和 package-lock.json 複製到工作目錄
# 這樣可以利用 Docker 層快取，如果依賴沒有變化，就不會重新安裝
COPY package*.json ./

# 安裝應用程式的所有依賴
RUN npm install

# 將所有應用程式程式碼複製到工作目錄
COPY . .

# 暴露應用程式運行的端口
EXPOSE 3000

# 定義啟動應用程式的命令
CMD ["node", "server.js"]
*/

// =============================================================================
// docker-compose.yml - 用於定義和運行多容器 Docker 應用程式 (已更新為直接使用 Node.js Image)
// =============================================================================

/*
version: '3.8'

services:
  app:
    image: node:22-alpine # <--- 直接指定 Node.js 映像
    ports:
      - "3000:3000" # 將主機的 3000 端口映射到容器的 3000 端口
    environment:
      NODE_ENV: development
      # DB_URI: mongodb://mongodb:27017/shorturl_db # 也可以在這裡設定環境變數，但我們已在 server.js 中硬編碼
    depends_on:
      mongodb: # <--- 修改 depends_on 語法以支持 condition
        condition: service_healthy # <--- 確保 mongodb 服務健康後才啟動 app
    volumes:
      - .:/app # 將本機目錄映射到容器，使程式碼在容器內可見
      - /app/node_modules # 排除 node_modules，避免本地和容器內的依賴衝突
    # 在容器啟動時執行 npm install 和啟動 server.js
    # 這確保了每次啟動容器時都會安裝依賴
    command: sh -c "npm install && npm start" # <--- 這裡從 node server.js 改為 npm start

  mongodb:
    image: mongo:latest # 使用最新的 MongoDB 官方映像
    ports:
      - "27017:27017" # 將主機的 27017 端口映射到容器的 27017 端口
    volumes:
      - mongodb_data:/data/db # 將 MongoDB 數據持久化到具名卷 (named volume)
    healthcheck: # <--- 添加 MongoDB 健康檢查
      test: echo 'db.runCommand("ping").ok' | mongosh --quiet # 測試 MongoDB 是否響應
      interval: 10s # 每 10 秒檢查一次
      timeout: 5s # 超時時間 5 秒
      retries: 5 # 重試 5 次
      start_period: 10s # 啟動後等待 10 秒再開始健康檢查

volumes:
  mongodb_data: # 定義一個具名卷用於儲存 MongoDB 數據
*/
